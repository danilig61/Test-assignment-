import math

class CityGrid:
    def __init__(self, n, m, block_percentage=0.3):
        self.n = n
        self.m = m
        self.grid = [[0] * m for _ in range(n)]
        self.block_percentage = block_percentage
        self.generate_blocks()

    def generate_blocks(self):
        num_blocks = int(self.n * self.m * self.block_percentage)
        block_positions = random.sample(range(self.n * self.m), num_blocks)
        for pos in block_positions:
            row = pos // self.m
            col = pos % self.m
            self.grid[row][col] = 1

    def place_tower(self, row, col, range_radius):
        for i in range(max(0, row - range_radius), min(self.n, row + range_radius + 1)):
            for j in range(max(0, col - range_radius), min(self.m, col + range_radius + 1)):
                self.grid[i][j] = 2

    def optimize_tower_placement(self):
        placed_towers = []
        city_copy = [row[:] for row in self.grid]  # Копия сетки города
        while True:
            uncovered_blocks = self.get_uncovered_blocks()
            if not uncovered_blocks:
                break
            max_distance = -1
            max_block = None
            for block in uncovered_blocks:
                distance = self.get_distance_to_towers(block, placed_towers)
                if distance > max_distance:
                    max_distance = distance
                    max_block = block
            tower_row = max_block[0]
            tower_col = max_block[1]
            if self.can_place_tower(city_copy, tower_row, tower_col):
                self.place_tower(tower_row, tower_col, 1)
                placed_towers.append((tower_row, tower_col))
                self.update_city_copy(city_copy, tower_row, tower_col)
            else:
                uncovered_blocks.remove(max_block)

    def can_place_tower(self, city_copy, row, col):
        if city_copy[row][col] == 1:
            return False
        n = len(city_copy)
        m = len(city_copy[0])
        for i in range(max(0, row - 1), min(n, row + 2)):
            for j in range(max(0, col - 1), min(m, col + 2)):
                if city_copy[i][j] == 2:
                    return False
        return True

    def update_city_copy(self, city_copy, row, col):
        n = len(city_copy)
        m = len(city_copy[0])
        for i in range(max(0, row - 1), min(n, row + 2)):
            for j in range(max(0, col - 1), min(m, col + 2)):
                city_copy[i][j] = 2

    def get_uncovered_blocks(self):
        uncovered_blocks = []
        for row in range(self.n):
            for col in range(self.m):
                if self.grid[row][col] == 0:
                    uncovered_blocks.append((row, col))
        return uncovered_blocks

    def get_distance_to_towers(self, block, towers):
        min_distance = math.inf
        for tower in towers:
            distance = self.calculate_distance(block, tower)
            min_distance = min(min_distance, distance)
        return min_distance

    def calculate_distance(self, block, tower):
        return abs(block[0] - tower[0]) + abs(block[1] - tower[1])

    def display_city(self):
        for row in self.grid:
            print(' '.join(str(cell) for cell in row))
# Пример использования:

city = CityGrid(5, 5)
city.optimize_tower_placement()
city.display_city()
